#!/bin/bash

# Generate .env files for backend, frontend, and root directory
# Uses configuration from bootstrap_config.env

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/lib_utils.sh"

CONFIG_FILE="$SCRIPT_DIR/bootstrap_config.env"

if [ ! -f "$CONFIG_FILE" ]; then
    print_error "Configuration file not found: $CONFIG_FILE"
    print_info "Run 02_gather_config.sh first"
    exit 1
fi



# Source configuration
source "$CONFIG_FILE"
# Default compose-accessible Authentik URL (service alias inside docker)
# If not provided in bootstrap_config.env, default to the service alias
# 'authentik' so containers can reach the server at port 9000.
if [ -z "$AUTHENTIK_URL" ]; then
    AUTHENTIK_URL="http://authentik:9000"
fi
AUTHENTIK_COMPOSE_URL="$AUTHENTIK_URL"

# Default external URL used by browsers/host. If not provided, prefer
# the host-mapped name `authentik.local` which you added to /etc/hosts.
if [ -z "$AUTHENTIK_EXTERNAL_URL" ]; then
    AUTHENTIK_EXTERNAL_URL="http://authentik.local:9000"
fi

# Generate Authentik secrets if not set
update_config=false
if [ -z "$AUTHENTIK_SECRET_KEY" ]; then
    AUTHENTIK_SECRET_KEY=$(openssl rand -hex 32)
    update_config=true
fi
if [ -z "$AUTHENTIK_BOOTSTRAP_PASSWORD" ]; then
    AUTHENTIK_BOOTSTRAP_PASSWORD=$(openssl rand -base64 16 | tr -d /=+ | cut -c1-16)"!"
    update_config=true
fi
if [ -z "$AUTHENTIK_BOOTSTRAP_EMAIL" ]; then
    AUTHENTIK_BOOTSTRAP_EMAIL="admin@example.com"
    update_config=true
fi
if [ -z "$AUTHENTIK_BOOTSTRAP_TOKEN" ]; then
    AUTHENTIK_BOOTSTRAP_TOKEN=$(openssl rand -hex 24)
    update_config=true
fi

# Persist generated secrets to bootstrap_config.env
if [ "$update_config" = true ]; then
    print_info "Persisting generated Authentik secrets to $CONFIG_FILE..."
    grep -v '^AUTHENTIK_SECRET_KEY=' "$CONFIG_FILE" | \
    grep -v '^AUTHENTIK_BOOTSTRAP_PASSWORD=' | \
    grep -v '^AUTHENTIK_BOOTSTRAP_EMAIL=' | \
    grep -v '^AUTHENTIK_BOOTSTRAP_TOKEN=' > "$CONFIG_FILE.tmp"
    mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
    cat >> "$CONFIG_FILE" <<EOF
AUTHENTIK_SECRET_KEY=$AUTHENTIK_SECRET_KEY
AUTHENTIK_BOOTSTRAP_PASSWORD=$AUTHENTIK_BOOTSTRAP_PASSWORD
AUTHENTIK_BOOTSTRAP_EMAIL=$AUTHENTIK_BOOTSTRAP_EMAIL
AUTHENTIK_BOOTSTRAP_TOKEN=$AUTHENTIK_BOOTSTRAP_TOKEN
EOF
fi

# Programmatically construct OIDC metadata URL for Authentik
# Use the compose-accessible URL for container-to-container communication
# during development (so services use the `authentik-server` hostname).
# Use hardcoded 'trailhead' slug since AUTHENTIK_CLIENT_ID is empty during bootstrap
if [ -n "$AUTHENTIK_URL" ]; then
    # Prefer compose/container URL for metadata (always reachable from other
    # containers). For development we also set the external URL to the
    # compose URL so local redirects use the container hostname.
    METADATA_URL="$AUTHENTIK_COMPOSE_URL/application/o/trailhead/.well-known/openid-configuration"
else
    METADATA_URL=""
fi

# Determine the external URL used by frontend/browser. In development we
# prefer the compose hostname so services redirect to `authentik-server` on
# the docker network instead of `localhost`.
if [ "$MODE" = "development" ]; then
    FINAL_AUTHENTIK_EXTERNAL_URL="$AUTHENTIK_COMPOSE_URL"
else
    FINAL_AUTHENTIK_EXTERNAL_URL="${AUTHENTIK_EXTERNAL_URL:-$AUTHENTIK_COMPOSE_URL}"
fi

print_header "=========================================="
print_header "Generating Environment Files"
print_header "=========================================="
echo ""

# Create backend .env file
print_info "Creating backend/.env..."
cat > backend/.env << EOF
# Trailhead - Environment Configuration
# Generated by bootstrap.sh on $(date)

# Database Configuration
POSTGRES_SERVER=postgres
POSTGRES_USER=$POSTGRES_USER
POSTGRES_PASSWORD=$POSTGRES_PASSWORD
POSTGRES_DB=$POSTGRES_DB
POSTGRES_PORT=$POSTGRES_PORT

# Security Configuration
SECRET_KEY=$SECRET_KEY
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=$ACCESS_TOKEN_EXPIRE_MINUTES
REFRESH_TOKEN_EXPIRE_DAYS=$REFRESH_TOKEN_EXPIRE_DAYS

# Application Configuration
PROJECT_NAME=Trailhead
VERSION=1.0.0
API_V1_STR=/api
DEBUG=$DEBUG

# CORS Configuration
BACKEND_CORS_ORIGINS=$BACKEND_CORS_ORIGINS

# Initial Admin User Configuration
INITIAL_ADMIN_EMAIL=$INITIAL_ADMIN_EMAIL

AUTHENTIK_URL=$AUTHENTIK_COMPOSE_URL
AUTHENTIK_CLIENT_ID=$AUTHENTIK_CLIENT_ID
AUTHENTIK_CLIENT_SECRET=$AUTHENTIK_CLIENT_SECRET
AUTHENTIK_EXTERNAL_URL=$FINAL_AUTHENTIK_EXTERNAL_URL
AUTHENTIK_ISSUER=${AUTHENTIK_ISSUER:-}
AUTHENTIK_METADATA_URL=$METADATA_URL
FRONTEND_URL=$FRONTEND_URL
EOF

print_success "backend/.env created"
echo ""

# Create frontend .env file
print_info "Creating frontend/.env..."
cat > frontend/.env << EOF
# Frontend Environment Configuration
# Generated by bootstrap.sh on $(date)

# Backend API URL
VITE_API_URL=$API_URL

VITE_AUTHENTIK_URL=$FINAL_AUTHENTIK_EXTERNAL_URL
VITE_AUTHENTIK_CLIENT_ID=$AUTHENTIK_CLIENT_ID
VITE_AUTHENTIK_ISSUER=${VITE_AUTHENTIK_ISSUER:-$AUTHENTIK_ISSUER}
VITE_AUTHENTIK_METADATA_URL=$METADATA_URL
EOF

print_success "frontend/.env created"
echo ""

# Create root .env file for docker-compose
print_info "Creating root .env..."
cat > .env << EOF
# Docker Compose Environment Variables
# Generated by bootstrap.sh on $(date)

# Deployment Mode
RESTART_POLICY=$RESTART_POLICY
DEBUG=$DEBUG
HEALTHCHECK_INTERVAL=$HEALTHCHECK_INTERVAL

# Compose profiles 
COMPOSE_PROFILES=$COMPOSE_PROFILE

# Database Configuration
POSTGRES_USER=$POSTGRES_USER
POSTGRES_PASSWORD=$POSTGRES_PASSWORD
POSTGRES_DB=$POSTGRES_DB
POSTGRES_PORT=$POSTGRES_PORT

# Authentik Database Configuration
AUTHENTIK_DB_USER=$AUTHENTIK_DB_USER
AUTHENTIK_DB_PASSWORD=$AUTHENTIK_DB_PASSWORD
AUTHENTIK_DB_NAME=$AUTHENTIK_DB_NAME

# Security
SECRET_KEY=$SECRET_KEY
ACCESS_TOKEN_EXPIRE_MINUTES=$ACCESS_TOKEN_EXPIRE_MINUTES
REFRESH_TOKEN_EXPIRE_DAYS=$REFRESH_TOKEN_EXPIRE_DAYS

# CORS
BACKEND_CORS_ORIGINS=$BACKEND_CORS_ORIGINS

# Initial Admin User
INITIAL_ADMIN_EMAIL=$INITIAL_ADMIN_EMAIL

AUTHENTIK_SECRET_KEY=$AUTHENTIK_SECRET_KEY
# Use compose-accessible URL for backend/runtime in the root .env so other
# containers can reach Authentik when running via docker-compose.
AUTHENTIK_URL=$AUTHENTIK_COMPOSE_URL
AUTHENTIK_EXTERNAL_URL=$FINAL_AUTHENTIK_EXTERNAL_URL
AUTHENTIK_BOOTSTRAP_PASSWORD=$AUTHENTIK_BOOTSTRAP_PASSWORD
AUTHENTIK_BOOTSTRAP_EMAIL=$AUTHENTIK_BOOTSTRAP_EMAIL
AUTHENTIK_BOOTSTRAP_TOKEN=$AUTHENTIK_BOOTSTRAP_TOKEN
AUTHENTIK_CLIENT_ID=$AUTHENTIK_CLIENT_ID
AUTHENTIK_CLIENT_SECRET=$AUTHENTIK_CLIENT_SECRET
AUTHENTIK_ISSUER=${AUTHENTIK_ISSUER:-}
AUTHENTIK_METADATA_URL=$METADATA_URL
FRONTEND_URL=$FRONTEND_URL

# Backend Configuration
BACKEND_COMMAND=sh -c 'echo "Waiting for database..." && sleep 5 && echo "Applying migrations with Atlas..." && atlas migrate apply --url "postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@postgres:$POSTGRES_PORT/$POSTGRES_DB?sslmode=disable" && echo "Initializing database..." && python -m app.db.init_db || echo "Database already initialized" && echo "Starting server..." && uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload'
BACKEND_VOLUME_MOUNT=$BACKEND_VOLUME_MOUNT
BACKEND_PORT=$BACKEND_PORT
EOF

if [ "$MODE" = "production" ]; then
    cat >> .env << EOF

# Frontend Build
VITE_API_URL=$API_URL

# SSL Configuration
SSL_CERT_PATH=$SSL_CERT_PATH
SSL_KEY_PATH=$SSL_KEY_PATH
EOF
fi

print_success "Root .env created"
echo ""

# Validate .env for malformed keys
print_info "Validating .env files..."
OFFENDING_KEYS=$(awk '
    /^[[:space:]]*#/ {next}
    /^[[:space:]]*$/ {next}
    { i = index($0, "=");
      if (i == 0) { print "MISSING_EQUALS: "$0; next }
      key = substr($0, 1, i-1);
      gsub(/^[ \t]+|[ \t]+$/, "", key);
      if (key ~ / /) print key
    }' .env || true)

if [ -n "$OFFENDING_KEYS" ]; then
    print_error "Detected malformed .env keys (contain spaces or invalid lines):"
    echo "$OFFENDING_KEYS"
    echo ""
    read -p "Attempt to auto-sanitize keys by replacing spaces with underscores? [Y/n]: " SANITIZE_CHOICE
    SANITIZE_CHOICE=${SANITIZE_CHOICE:-Y}
    if [[ "$SANITIZE_CHOICE" =~ ^[Yy]$ ]]; then
        cp .env .env.bak
        awk '
            /^[[:space:]]*#/ {print; next}
            /^[[:space:]]*$/ {print; next}
            { i = index($0, "=");
              if (i == 0) { print $0; next }
              key = substr($0, 1, i-1);
              val = substr($0, i+1);
              gsub(/^[ \t]+|[ \t]+$/, "", key);
              gsub(/^[ \t]+|[ \t]+$/, "", val);
              gsub(/[ \t]+/, "_", key);
              print key "=" val
            }' .env.bak > .env
        print_success "Sanitized .env saved (original backed up to .env.bak)"
    else
        print_error "Please fix .env (remove spaces in keys) and re-run. Aborting."
        exit 1
    fi
else
    print_success ".env validation passed"
fi
echo ""

# Create credentials file if requested
if [ "$SAVE_CREDS" = true ]; then
    print_info "Creating credentials.txt..."
    
    cat > credentials.txt << EOF
# Trailhead - Credentials
# Generated by bootstrap.sh on $(date)
#
# ⚠️  IMPORTANT: Keep this file secure and do not commit it to version control!
# This file is automatically added to .gitignore

========================================
DEPLOYMENT CONFIGURATION
========================================
Mode: $MODE
Host URI: $HOST_URI
Domain: $DOMAIN

========================================
DATABASE CREDENTIALS
========================================
PostgreSQL User: $POSTGRES_USER
PostgreSQL Password: $POSTGRES_PASSWORD
PostgreSQL Database: $POSTGRES_DB
PostgreSQL Port: $POSTGRES_PORT

Authentik Database User: $AUTHENTIK_DB_USER
Authentik Database Password: $AUTHENTIK_DB_PASSWORD
Authentik Database Name: $AUTHENTIK_DB_NAME

========================================
SECURITY CONFIGURATION
========================================
Secret Key: $SECRET_KEY
Access Token Expire Minutes: $ACCESS_TOKEN_EXPIRE_MINUTES
Refresh Token Expire Days: $REFRESH_TOKEN_EXPIRE_DAYS
Authentik Secret Key: $AUTHENTIK_SECRET_KEY

========================================
ADMIN USER CONFIGURATION
========================================
Admin Email: $INITIAL_ADMIN_EMAIL
Authentik Bootstrap Password: $AUTHENTIK_BOOTSTRAP_PASSWORD
Authentik Bootstrap Token: $AUTHENTIK_BOOTSTRAP_TOKEN

NOTE: The bootstrap password is used to log in to Authentik admin panel.
On first sign-in to the app with the admin email, you will be granted admin role.
Authentication is handled by Authentik - no passwords are stored in the app database.

========================================
AUTHENTIK CONFIGURATION
========================================
Authentik URL: $AUTHENTIK_URL
Authentik Client ID: (Configure in Authentik dashboard)
Authentik Client Secret: (Configure in Authentik dashboard)

========================================
ACCESS URLS
========================================
EOF

    if [ "$MODE" = "development" ]; then
        cat >> credentials.txt << EOF
Frontend: http://localhost:3000
Backend API: http://localhost:8000
API Docs (Swagger): http://localhost:8000/docs
API Docs (ReDoc): http://localhost:8000/redoc
Authentik Admin: $AUTHENTIK_URL
EOF
    else
        cat >> credentials.txt << EOF
Application: $HOST_URI
API Docs: $HOST_URI/docs
Authentik Admin: $AUTHENTIK_URL
EOF
    fi

    print_success "Credentials saved to credentials.txt"
    add_to_gitignore "credentials.txt"
    echo ""
fi

print_success "All environment files created successfully!"
