#!/usr/bin/env python3
"""
JWT Token Security Testing
Tests JWT token handling, expiration, and validation
"""

import requests
import jwt
import time
from datetime import datetime, timedelta
import json


class JWTSecurityTester:
    """Test JWT token security"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url.rstrip('/')
    
    def test_expired_token(self):
        """Test that expired tokens are rejected"""
        print("\n[TEST] Expired Token Handling")
        
        # Create an expired token (requires your SECRET_KEY)
        # Note: This is for testing only
        expired_payload = {
            'sub': 'test_user',
            'exp': datetime.utcnow() - timedelta(hours=1),  # Expired 1 hour ago
            'iat': datetime.utcnow() - timedelta(hours=2),
            'type': 'access'
        }
        
        # You would need the actual SECRET_KEY to create a valid-looking token
        # For now, test with a clearly invalid token
        fake_token = "expired.token.here"
        
        response = requests.get(
            f"{self.base_url}/api/clerk/me",
            headers={'Authorization': f'Bearer {fake_token}'}
        )
        
        if response.status_code in [401, 403]:
            print("✅ PASS: Expired tokens properly rejected")
            return True
        else:
            print(f"❌ FAIL: Expired token accepted (status: {response.status_code})")
            return False
    
    def test_malformed_token(self):
        """Test that malformed tokens are rejected"""
        print("\n[TEST] Malformed Token Handling")
        
        test_cases = [
            ("empty", ""),
            ("invalid_format", "not.a.jwt"),
            ("missing_parts", "header.payload"),
            ("too_many_parts", "a.b.c.d.e"),
            ("invalid_chars", "!!!.@@@.###"),
        ]
        
        passed = True
        for name, token in test_cases:
            response = requests.get(
                f"{self.base_url}/api/clerk/me",
                headers={'Authorization': f'Bearer {token}'}
            )
            
            if response.status_code not in [401, 403]:
                print(f"❌ FAIL: {name} token not rejected (status: {response.status_code})")
                passed = False
        
        if passed:
            print("✅ PASS: All malformed tokens rejected")
        
        return passed
    
    def test_missing_token(self):
        """Test that requests without tokens are rejected"""
        print("\n[TEST] Missing Token Handling")
        
        response = requests.get(f"{self.base_url}/api/clerk/me")
        
        if response.status_code in [401, 403]:
            print("✅ PASS: Missing token properly rejected")
            return True
        else:
            print(f"❌ FAIL: Request without token accepted (status: {response.status_code})")
            return False
    
    def test_token_in_wrong_location(self):
        """Test that tokens in wrong locations are not accepted"""
        print("\n[TEST] Token Location Validation")
        
        fake_token = "fake_token_12345"
        
        # Try token in query string (should not work)
        response1 = requests.get(
            f"{self.base_url}/api/clerk/me",
            params={'token': fake_token}
        )
        
        # Try token in POST body (should not work)
        response2 = requests.post(
            f"{self.base_url}/api/clerk/me",
            json={'token': fake_token}
        )
        
        if response1.status_code in [401, 403] and response2.status_code in [401, 403, 405]:
            print("✅ PASS: Tokens only accepted in Authorization header")
            return True
        else:
            print(f"❌ FAIL: Token accepted from wrong location")
            return False
    
    def test_algorithm_confusion(self):
        """Test for algorithm confusion attacks"""
        print("\n[TEST] Algorithm Confusion Attack")
        
        # Try to create a token with 'none' algorithm
        header = {
            'alg': 'none',
            'typ': 'JWT'
        }
        payload = {
            'sub': 'attacker',
            'role': 'admin',
            'exp': (datetime.utcnow() + timedelta(hours=1)).timestamp()
        }
        
        # Create unsigned token
        import base64
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(header).encode()
        ).decode().rstrip('=')
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(payload).encode()
        ).decode().rstrip('=')
        
        none_token = f"{header_b64}.{payload_b64}."
        
        response = requests.get(
            f"{self.base_url}/api/clerk/me",
            headers={'Authorization': f'Bearer {none_token}'}
        )
        
        if response.status_code in [401, 403]:
            print("✅ PASS: 'none' algorithm rejected")
            return True
        else:
            print(f"❌ FAIL: 'none' algorithm accepted (status: {response.status_code})")
            return False
    
    def run_all_tests(self):
        """Run all JWT security tests"""
        print("\n" + "="*60)
        print("JWT SECURITY TESTING")
        print("="*60)
        
        results = [
            self.test_missing_token(),
            self.test_malformed_token(),
            self.test_expired_token(),
            self.test_token_in_wrong_location(),
            self.test_algorithm_confusion(),
        ]
        
        passed = sum(results)
        total = len(results)
        
        print("\n" + "="*60)
        print(f"RESULTS: {passed}/{total} tests passed")
        print("="*60 + "\n")
        
        return all(results)


if __name__ == '__main__':
    import sys
    
    url = sys.argv[1] if len(sys.argv) > 1 else 'http://localhost:8000'
    
    tester = JWTSecurityTester(url)
    success = tester.run_all_tests()
    
    sys.exit(0 if success else 1)
