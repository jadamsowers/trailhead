#!/usr/bin/env python3
"""
Automated Security Testing Suite for Trailhead Backend
Tests for OWASP Top 10 vulnerabilities and security misconfigurations
"""

import requests
import json
import sys
import time
from typing import Dict, List, Tuple
from dataclasses import dataclass
from datetime import datetime
import argparse


@dataclass
class TestResult:
    """Result of a security test"""
    test_name: str
    passed: bool
    severity: str  # 'critical', 'high', 'medium', 'low', 'info'
    details: str
    recommendation: str = ""


class SecurityTester:
    """Automated security testing for Trailhead API"""
    
    def __init__(self, base_url: str, verbose: bool = False):
        self.base_url = base_url.rstrip('/')
        self.verbose = verbose
        self.results: List[TestResult] = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Trailhead-Security-Scanner/1.0'
        })
    
    def log(self, message: str):
        """Log message if verbose mode enabled"""
        if self.verbose:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] {message}")
    
    def test_security_headers(self) -> TestResult:
        """Test for presence of security headers"""
        self.log("Testing security headers...")
        
        try:
            response = self.session.get(f"{self.base_url}/api/health")
            headers = response.headers
            
            required_headers = {
                'X-Frame-Options': 'DENY',
                'X-Content-Type-Options': 'nosniff',
                'X-XSS-Protection': '1; mode=block',
                'Content-Security-Policy': 'default-src',
                'Referrer-Policy': 'strict-origin',
            }
            
            missing = []
            wrong_value = []
            
            for header, expected_value in required_headers.items():
                if header not in headers:
                    missing.append(header)
                elif expected_value and expected_value not in headers[header]:
                    wrong_value.append(f"{header}: {headers[header]}")
            
            if missing or wrong_value:
                details = []
                if missing:
                    details.append(f"Missing headers: {', '.join(missing)}")
                if wrong_value:
                    details.append(f"Incorrect values: {', '.join(wrong_value)}")
                
                return TestResult(
                    test_name="Security Headers",
                    passed=False,
                    severity="high",
                    details="; ".join(details),
                    recommendation="Ensure all security headers are properly configured"
                )
            
            return TestResult(
                test_name="Security Headers",
                passed=True,
                severity="info",
                details="All required security headers present and correct"
            )
        
        except Exception as e:
            return TestResult(
                test_name="Security Headers",
                passed=False,
                severity="high",
                details=f"Error testing headers: {str(e)}",
                recommendation="Check if server is running"
            )
    
    def test_cors_configuration(self) -> TestResult:
        """Test CORS configuration for security issues"""
        self.log("Testing CORS configuration...")
        
        try:
            # Test with malicious origin
            response = self.session.options(
                f"{self.base_url}/api/health",
                headers={'Origin': 'https://evil.com'}
            )
            
            allow_origin = response.headers.get('Access-Control-Allow-Origin', '')
            allow_credentials = response.headers.get('Access-Control-Allow-Credentials', '')
            
            if allow_origin == '*' and allow_credentials.lower() == 'true':
                return TestResult(
                    test_name="CORS Configuration",
                    passed=False,
                    severity="critical",
                    details="CORS allows any origin with credentials enabled",
                    recommendation="Restrict CORS origins to known domains"
                )
            
            if allow_origin == '*':
                return TestResult(
                    test_name="CORS Configuration",
                    passed=False,
                    severity="medium",
                    details="CORS allows any origin",
                    recommendation="Restrict CORS to specific trusted origins"
                )
            
            return TestResult(
                test_name="CORS Configuration",
                passed=True,
                severity="info",
                details="CORS properly restricted"
            )
        
        except Exception as e:
            return TestResult(
                test_name="CORS Configuration",
                passed=False,
                severity="medium",
                details=f"Error testing CORS: {str(e)}"
            )
    
    def test_sql_injection(self) -> TestResult:
        """Test for SQL injection vulnerabilities"""
        self.log("Testing for SQL injection...")
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "admin'--",
            "' UNION SELECT NULL--",
            "1' AND 1=1--"
        ]
        
        vulnerabilities = []
        
        # Test on public endpoints
        endpoints = [
            f"/api/outings",
        ]
        
        try:
            for endpoint in endpoints:
                for payload in sql_payloads:
                    # Test query parameters
                    response = self.session.get(
                        f"{self.base_url}{endpoint}",
                        params={'id': payload}
                    )
                    
                    # Look for SQL error messages
                    error_indicators = [
                        'sql', 'syntax', 'mysql', 'postgresql', 'sqlite',
                        'ora-', 'sqlstate', 'database error'
                    ]
                    
                    response_text = response.text.lower()
                    for indicator in error_indicators:
                        if indicator in response_text:
                            vulnerabilities.append(
                                f"{endpoint} with payload '{payload[:20]}...'"
                            )
                            break
            
            if vulnerabilities:
                return TestResult(
                    test_name="SQL Injection",
                    passed=False,
                    severity="critical",
                    details=f"Possible SQL injection: {', '.join(vulnerabilities)}",
                    recommendation="Ensure all queries use parameterized statements"
                )
            
            return TestResult(
                test_name="SQL Injection",
                passed=True,
                severity="info",
                details="No SQL injection vulnerabilities detected"
            )
        
        except Exception as e:
            return TestResult(
                test_name="SQL Injection",
                passed=False,
                severity="high",
                details=f"Error testing SQL injection: {str(e)}"
            )
    
    def test_xss_vulnerabilities(self) -> TestResult:
        """Test for Cross-Site Scripting vulnerabilities"""
        self.log("Testing for XSS vulnerabilities...")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
        ]
        
        vulnerabilities = []
        
        try:
            # Test reflection in responses
            response = self.session.get(
                f"{self.base_url}/api/outings",
                params={'search': xss_payloads[0]}
            )
            
            # Check if payload is reflected unescaped
            for payload in xss_payloads:
                if payload in response.text:
                    vulnerabilities.append("Query parameter reflection")
                    break
            
            if vulnerabilities:
                return TestResult(
                    test_name="Cross-Site Scripting (XSS)",
                    passed=False,
                    severity="high",
                    details=f"Possible XSS: {', '.join(vulnerabilities)}",
                    recommendation="Ensure all user input is properly escaped/sanitized"
                )
            
            return TestResult(
                test_name="Cross-Site Scripting (XSS)",
                passed=True,
                severity="info",
                details="No XSS vulnerabilities detected"
            )
        
        except Exception as e:
            return TestResult(
                test_name="Cross-Site Scripting (XSS)",
                passed=False,
                severity="high",
                details=f"Error testing XSS: {str(e)}"
            )
    
    def test_authentication_bypass(self) -> TestResult:
        """Test for authentication bypass vulnerabilities"""
        self.log("Testing authentication bypass...")
        
        # Endpoints that should require authentication
        protected_endpoints = [
            ("/api/clerk/me", "GET"),
            ("/api/signups", "POST"),
            ("/api/outings", "POST"),
            ("/api/family", "GET"),
        ]
        
        bypassed = []
        
        try:
            for endpoint, method in protected_endpoints:
                if method == "GET":
                    response = self.session.get(f"{self.base_url}{endpoint}")
                elif method == "POST":
                    response = self.session.post(
                        f"{self.base_url}{endpoint}",
                        json={}
                    )
                
                # Should return 401 or 403, not 200
                if response.status_code == 200:
                    bypassed.append(f"{method} {endpoint}")
            
            if bypassed:
                return TestResult(
                    test_name="Authentication Bypass",
                    passed=False,
                    severity="critical",
                    details=f"Endpoints accessible without auth: {', '.join(bypassed)}",
                    recommendation="Ensure all protected endpoints require authentication"
                )
            
            return TestResult(
                test_name="Authentication Bypass",
                passed=True,
                severity="info",
                details="All protected endpoints require authentication"
            )
        
        except Exception as e:
            return TestResult(
                test_name="Authentication Bypass",
                passed=False,
                severity="critical",
                details=f"Error testing authentication: {str(e)}"
            )
    
    def test_rate_limiting(self) -> TestResult:
        """Test rate limiting implementation"""
        self.log("Testing rate limiting...")
        
        try:
            # Make rapid requests to a public endpoint
            endpoint = f"{self.base_url}/api/outings/available"
            rate_limited = False
            
            for i in range(70):  # Test above typical limit
                response = self.session.get(endpoint)
                if response.status_code == 429:
                    rate_limited = True
                    break
                time.sleep(0.1)
            
            if not rate_limited:
                return TestResult(
                    test_name="Rate Limiting",
                    passed=False,
                    severity="medium",
                    details="No rate limiting detected after 70 requests",
                    recommendation="Implement rate limiting to prevent abuse"
                )
            
            return TestResult(
                test_name="Rate Limiting",
                passed=True,
                severity="info",
                details="Rate limiting is working"
            )
        
        except Exception as e:
            return TestResult(
                test_name="Rate Limiting",
                passed=False,
                severity="medium",
                details=f"Error testing rate limiting: {str(e)}"
            )
    
    def test_information_disclosure(self) -> TestResult:
        """Test for information disclosure in error messages"""
        self.log("Testing information disclosure...")
        
        try:
            # Try to trigger errors
            test_cases = [
                (f"{self.base_url}/api/nonexistent", "GET"),
                (f"{self.base_url}/api/outings/invalid-uuid", "GET"),
            ]
            
            leaked_info = []
            
            for url, method in test_cases:
                if method == "GET":
                    response = self.session.get(url)
                
                # Check for leaked information
                sensitive_patterns = [
                    'traceback',
                    'file "/app/',
                    'file "/usr/',
                    'postgresql',
                    'sqlalchemy',
                    'stack trace',
                    '.py", line',
                ]
                
                response_text = response.text.lower()
                for pattern in sensitive_patterns:
                    if pattern in response_text:
                        leaked_info.append(pattern)
                        break
            
            if leaked_info:
                return TestResult(
                    test_name="Information Disclosure",
                    passed=False,
                    severity="medium",
                    details=f"Error messages leak information: {', '.join(set(leaked_info))}",
                    recommendation="Sanitize error messages in production"
                )
            
            return TestResult(
                test_name="Information Disclosure",
                passed=True,
                severity="info",
                details="Error messages properly sanitized"
            )
        
        except Exception as e:
            return TestResult(
                test_name="Information Disclosure",
                passed=False,
                severity="medium",
                details=f"Error testing information disclosure: {str(e)}"
            )
    
    def test_https_enforcement(self) -> TestResult:
        """Test HTTPS enforcement"""
        self.log("Testing HTTPS enforcement...")
        
        try:
            if not self.base_url.startswith('https://'):
                return TestResult(
                    test_name="HTTPS Enforcement",
                    passed=False,
                    severity="high",
                    details="API not served over HTTPS",
                    recommendation="Enable HTTPS in production"
                )
            
            # Check HSTS header
            response = self.session.get(f"{self.base_url}/api/health")
            hsts = response.headers.get('Strict-Transport-Security', '')
            
            if not hsts:
                return TestResult(
                    test_name="HTTPS Enforcement",
                    passed=False,
                    severity="medium",
                    details="HSTS header not present",
                    recommendation="Enable HSTS header for HTTPS enforcement"
                )
            
            return TestResult(
                test_name="HTTPS Enforcement",
                passed=True,
                severity="info",
                details="HTTPS properly enforced with HSTS"
            )
        
        except Exception as e:
            return TestResult(
                test_name="HTTPS Enforcement",
                passed=False,
                severity="high",
                details=f"Error testing HTTPS: {str(e)}"
            )
    
    def test_authorization_flaws(self) -> TestResult:
        """Test for broken access control"""
        self.log("Testing authorization flaws...")
        
        try:
            # Try to access admin endpoints without proper token
            admin_endpoints = [
                "/api/clerk/users",
                "/api/outings",  # POST requires admin
            ]
            
            # Use a fake/invalid token
            headers = {'Authorization': 'Bearer fake_token_12345'}
            
            accessible = []
            for endpoint in admin_endpoints:
                response = self.session.get(
                    f"{self.base_url}{endpoint}",
                    headers=headers
                )
                
                # Should return 401/403, not 200
                if response.status_code == 200:
                    accessible.append(endpoint)
            
            if accessible:
                return TestResult(
                    test_name="Authorization Flaws",
                    passed=False,
                    severity="critical",
                    details=f"Admin endpoints accessible: {', '.join(accessible)}",
                    recommendation="Verify JWT tokens and check user roles"
                )
            
            return TestResult(
                test_name="Authorization Flaws",
                passed=True,
                severity="info",
                details="Authorization properly enforced"
            )
        
        except Exception as e:
            return TestResult(
                test_name="Authorization Flaws",
                passed=False,
                severity="critical",
                details=f"Error testing authorization: {str(e)}"
            )
    
    def test_verbose_errors(self) -> TestResult:
        """Test for overly verbose error messages"""
        self.log("Testing error verbosity...")
        
        try:
            # Trigger various errors
            response = self.session.post(
                f"{self.base_url}/api/signups",
                json={"invalid": "data"}
            )
            
            # Check for detailed error info
            text = response.text.lower()
            
            if any(x in text for x in ['exception', 'error_type', 'traceback']):
                return TestResult(
                    test_name="Verbose Error Messages",
                    passed=False,
                    severity="medium",
                    details="Error messages contain internal details",
                    recommendation="Use generic error messages with error IDs"
                )
            
            return TestResult(
                test_name="Verbose Error Messages",
                passed=True,
                severity="info",
                details="Error messages properly sanitized"
            )
        
        except Exception as e:
            return TestResult(
                test_name="Verbose Error Messages",
                passed=False,
                severity="medium",
                details=f"Error testing: {str(e)}"
            )
    
    def run_all_tests(self) -> List[TestResult]:
        """Run all security tests"""
        print(f"\n{'='*60}")
        print(f"Starting Security Test Suite")
        print(f"Target: {self.base_url}")
        print(f"{'='*60}\n")
        
        tests = [
            self.test_security_headers,
            self.test_cors_configuration,
            self.test_sql_injection,
            self.test_xss_vulnerabilities,
            self.test_authentication_bypass,
            self.test_rate_limiting,
            self.test_information_disclosure,
            self.test_https_enforcement,
            self.test_authorization_flaws,
            self.test_verbose_errors,
        ]
        
        for test_func in tests:
            result = test_func()
            self.results.append(result)
            
            # Print result
            status = "âœ… PASS" if result.passed else "âŒ FAIL"
            severity = f"[{result.severity.upper()}]" if not result.passed else ""
            print(f"{status} {severity} {result.test_name}")
            if not result.passed or self.verbose:
                print(f"    â””â”€ {result.details}")
            if result.recommendation:
                print(f"    â””â”€ Recommendation: {result.recommendation}")
            print()
        
        return self.results
    
    def generate_report(self) -> Dict:
        """Generate summary report"""
        total = len(self.results)
        passed = sum(1 for r in self.results if r.passed)
        failed = total - passed
        
        by_severity = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': [],
            'info': []
        }
        
        for result in self.results:
            if not result.passed:
                by_severity[result.severity].append(result)
        
        return {
            'total_tests': total,
            'passed': passed,
            'failed': failed,
            'critical': len(by_severity['critical']),
            'high': len(by_severity['high']),
            'medium': len(by_severity['medium']),
            'low': len(by_severity['low']),
            'by_severity': by_severity
        }


def main():
    parser = argparse.ArgumentParser(
        description='Automated security testing for Trailhead API'
    )
    parser.add_argument(
        '--url',
        default='http://localhost:8000',
        help='Base URL of the API (default: http://localhost:8000)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output'
    )
    parser.add_argument(
        '--output',
        help='Output file for JSON report'
    )
    
    args = parser.parse_args()
    
    tester = SecurityTester(args.url, verbose=args.verbose)
    results = tester.run_all_tests()
    report = tester.generate_report()
    
    # Print summary
    print(f"\n{'='*60}")
    print(f"SECURITY TEST SUMMARY")
    print(f"{'='*60}")
    print(f"Total Tests: {report['total_tests']}")
    print(f"Passed: {report['passed']}")
    print(f"Failed: {report['failed']}")
    print()
    print(f"By Severity:")
    print(f"  ðŸ”´ Critical: {report['critical']}")
    print(f"  ðŸŸ  High: {report['high']}")
    print(f"  ðŸŸ¡ Medium: {report['medium']}")
    print(f"  ðŸŸ¢ Low: {report['low']}")
    print(f"{'='*60}\n")
    
    # Save report if requested
    if args.output:
        with open(args.output, 'w') as f:
            # Convert TestResult objects to dictionaries
            serialized_results = []
            for r in results:
                serialized_results.append({
                    'test': r.test_name,
                    'passed': r.passed,
                    'severity': r.severity if r.severity else 'none',
                    'details': r.details,
                    'recommendation': r.recommendation if r.recommendation else ''
                })
            
            # Create summary without by_severity (which contains TestResult objects)
            summary = {
                'total_tests': report['total_tests'],
                'passed': report['passed'],
                'failed': report['failed'],
                'critical': report['critical'],
                'high': report['high'],
                'medium': report['medium'],
                'low': report['low']
            }
            
            json.dump({
                'timestamp': datetime.now().isoformat(),
                'target': args.url,
                'summary': summary,
                'results': serialized_results
            }, f, indent=2)
        print(f"Report saved to: {args.output}")
    
    # Exit with error code if tests failed
    sys.exit(0 if report['failed'] == 0 else 1)


if __name__ == '__main__':
    main()
